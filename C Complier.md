# C Complier

<p align="right">2020.11.14 Sat. Tom.</p>

## 1st. 预处理

读取文件，将所有的Include的头文件和宏定义替换成真正的内容。代码体积增加。需要实现一个文件读写的库，需要允许从文件的指定位置读取指定长度字符。

| File     | Features       |
| -------- | -------------- |
| Symbol.c | 符号表实现     |
| Symbol.h | 符号表头文件   |
| File.c   | 文件相关实现   |
| File.h   | 文件相关头文件 |

Token: <种别码，属性值>

| Type   | Mode               |
| ------ | ------------------ |
| 关键字 | 一次一码           |
| 标识符 | 多词一码           |
| 常量   | 一型一码           |
| 运算符 | 一次一码或一型一码 |
| 界限符 | 一次一码           |

| Type     | Content                        |
| -------- | ------------------------------ |
| 终结符   | 标识符、数字、关键字、特殊标点 |
| 非终结符 | 表达式、语句                   |

`符号表由两人完成，文件相关由一人完成。`



## 2nd. 语法制导翻译

语法指导翻译器逐行扫描，调用词法分析器和语法分析器对代码进行处理，设计避免二义性、不含左递归的文法，获取符合语法的语法树，对于不符合语法的报错并进行恢复继续提取。语义分析包括手机标识符属性信息和基础的语义检查，包括符合语法结构但无实际意义的部分。完成语法树提取后需要进行许多检查工作，包括但不限于类型检查、边界检查、作用域检查、内存管理、参数传递机制等内容，遇到错误进行恢复和错误提示。

| File (忽略头文件) | Features     |
| ----------------- | ------------ |
| Lex.c             | 词法分析     |
| Yacc.c            | 语法分析     |
| Prop.c            | 语法制导翻译 |
| Recover.c         | 错误恢复     |

`词法分析器由两人人完成（对应第一部分）。语法分析器由三人完成。另两人人完成错误恢复。`

```Markdown
# Lex Format

全局声明 常量 变量 头文件等
%{
符号常量定义
}%
正规定义
定义式 正则表达式
%%
模式定义（转换规则）
%%
辅助函数 如添加符号表函数等
install_id()
install_num()
main()

```

```Markdown
# YACC Format

%{
定义声明段 包括include的项目和extern函数链接，token记号声明和type类型声明。
%}

%%  
文法规则段
%%  

void yyerror(const char *s)
int main()
```



## 3rd. 中间代码生成

生成的汇编代码可以汇编并运行测试，中间代码生成可能包括多层的中间表示，朝着抽象层次降低的方向。基本快、流程图、寄存器分配与指定、窥孔优化等。

`中间代码生成由三人完成。另两人完成测试。`



## 4th. 代码优化

中间代码通过测试后，对生成的汇编代码进行优化，主要是提升执行速度，优化掉不必要的代码，进行数据流分析和类型优化。不作为重点部分。

`代码优化由三人完成。剩余两人完成报告。`



## 加分项

目前个人认为结构体和指针或数组可能实现起来相对容易。手工实现词法分析和语法分析工程量较大，函数需要考虑函数栈和函数调用时参数的调用方式。等整个编译器基本功能完成了再看看怎么添吧。



从汇编代码到二进制可执行文件还需要汇编和链接才能真正完成，这个部分不属于大作业范畴，可以暂时忽略。